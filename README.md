# my-group

Educational miniature algebra library focusing on finite groups. Provides:

* Minimal interfaces: `Element`, `Operation<E>`, `Group<E>`
* Concrete implementations: cyclic groups (Z_n), dihedral groups (D_n), symmetric groups (S_n)
* **Direct products**: construct G₁ × G₂ from any two finite groups
* **Subgroup generation**: generate subgroups from generators, enumerate all subgroups, compute normalizers/centralizers
* Utilities: group verifier (axioms), operation (Cayley) table formatter (plain text / Markdown / LaTeX)
* Property-based tests (jqwik) asserting axioms for randomly chosen cyclic groups

## Why
Designed as a teaching aid: show how abstract algebra definitions map to small, immutable Java types using modern language features (records, pattern matching, streams) while keeping API friction low.

## Getting Started

```java
import d021248.group.cyclic.CyclicGroup;
import d021248.group.cyclic.CyclicElement;

var g = new CyclicGroup(7); // Z_7 under addition mod 7
var a = new CyclicElement(3, 7);
var b = new CyclicElement(6, 7);
var sum = g.operate(a, b); // 3 + 6 = 9 ≡ 2 (mod 7)
System.out.println(sum); // 2 (mod 7)
System.out.println(a.inverse()); // 4 (mod 7)
```

Generate / visualize an operation (Cayley) table:

```java
import d021248.group.GroupTableFormatter;
import d021248.group.FiniteGroup;

FiniteGroup<?> fg = g; // any finite group
var cfg = GroupTableFormatter.forGroup(fg).build();
System.out.println(GroupTableFormatter.toMarkdown(cfg)); // Markdown
System.out.println(GroupTableFormatter.toPlainText(cfg)); // tab-separated
System.out.println(GroupTableFormatter.toLatex(cfg)); // LaTeX tabular
```

Custom ordering & identity highlighting control:

```java
var cfgCustom = GroupTableFormatter.forGroup(fg)
	.ordering((e1, e2) -> e1.toString().compareTo(e2.toString()))
	.highlightIdentity(false)
	.build();
System.out.println(GroupTableFormatter.toMarkdown(cfgCustom));
```

Verify axioms and check properties:

```java
import d021248.group.util.GroupVerifier;
var result = GroupVerifier.verify(g);
System.out.println(result.summary());

// Check if group is abelian
boolean abelian = g.isAbelian(); // true for cyclic groups

// Compute exponent (lcm of element orders)
int exp = g.exponent(); // for Z_6, exponent = 6
```

Build direct products:

```java
import d021248.group.GroupFactory;
import d021248.group.product.DirectProduct;
import d021248.group.product.ProductElement;

var z2 = GroupFactory.cyclic(2);
var z3 = GroupFactory.cyclic(3);
var z2xz3 = GroupFactory.directProduct(z2, z3);
System.out.println("Z_2 × Z_3 order: " + z2xz3.order()); // 6

// Klein four-group V_4 = Z_2 × Z_2
var v4 = GroupFactory.directProduct(GroupFactory.cyclic(2), GroupFactory.cyclic(2));
```

Generate and analyze subgroups:

```java
import d021248.group.subgroup.SubgroupGenerator;
import d021248.group.subgroup.Subgroup;

var z12 = GroupFactory.cyclic(12);
// Generate subgroup from generators
Subgroup<CyclicElement> h = SubgroupGenerator.generate(z12, Set.of(new CyclicElement(3, 12)));
System.out.println("Order: " + h.order()); // 4
System.out.println("Index: " + h.index()); // 3 (Lagrange's theorem)

// Find all cyclic subgroups
List<Subgroup<CyclicElement>> cyclicSubs = SubgroupGenerator.cyclicSubgroups(z12);

// Check normality
boolean normal = SubgroupGenerator.isNormal(z12, h); // true (abelian group)

// Compute normalizer and centralizer
Subgroup<CyclicElement> normalizer = SubgroupGenerator.normalizer(z12, h);
Subgroup<CyclicElement> centralizer = SubgroupGenerator.centralizer(z12, h);

// Find maximal subgroups (proper subgroups that are not contained in any other proper subgroup)
List<Subgroup<CyclicElement>> maximal = SubgroupGenerator.maximalSubgroups(z12);
System.out.println("Maximal subgroups: " + maximal.size()); // 2 for Z_12

// Compute Frattini subgroup Φ(G) = intersection of all maximal subgroups
Subgroup<CyclicElement> frattini = SubgroupGenerator.frattiniSubgroup(z12);
System.out.println("Φ(Z_12) order: " + frattini.order()); // 1 (trivial)

// Compute center Z(G) = elements commuting with all elements
Subgroup<CyclicElement> center = SubgroupGenerator.center(z12);
System.out.println("Z(Z_12) order: " + center.order()); // 12 (abelian group)

// Compute commutator subgroup [G,G] = subgroup generated by commutators
SymmetricGroup s3 = GroupFactory.symmetric(3);
Subgroup<Permutation> commutator = SubgroupGenerator.commutatorSubgroup(s3);
System.out.println("[S_3,S_3] order: " + commutator.order()); // 3 (equals A_3)
```

Compute conjugacy classes and analyze group structure:

```java
import d021248.group.conjugacy.ConjugacyAnalyzer;
import d021248.group.conjugacy.ConjugacyClass;

SymmetricGroup s3 = GroupFactory.symmetric(3);

// Partition group into conjugacy classes
List<ConjugacyClass<Permutation>> classes = ConjugacyAnalyzer.conjugacyClasses(s3);
System.out.println("Number of classes: " + classes.size()); // 3

// Get conjugacy class of specific element
Permutation g = new Permutation(new int[]{2, 1, 3}); // (1 2)
Set<Permutation> cl = ConjugacyAnalyzer.conjugacyClass(s3, g);
System.out.println("Class size: " + cl.size()); // 3 (all transpositions)

// Class equation: |G| = sum of |cl(g)|
Map<Integer, Long> equation = ConjugacyAnalyzer.classEquation(s3);
equation.forEach((size, count) -> 
    System.out.println(count + " class(es) of size " + size));
// Output: 1 class(es) of size 1
//         1 class(es) of size 2
//         1 class(es) of size 3

// Check if two elements are conjugate
Permutation h1 = new Permutation(new int[]{2, 1, 3}); // (1 2)
Permutation h2 = new Permutation(new int[]{1, 3, 2}); // (2 3)
boolean conjugate = ConjugacyAnalyzer.areConjugate(s3, h1, h2); // true

// Compute centralizer C_G(g) using orbit-stabilizer: |cl(g)| × |C_G(g)| = |G|
Subgroup<Permutation> centralizer = ConjugacyAnalyzer.elementCentralizer(s3, g);
System.out.println("|cl(g)| × |C_G(g)| = " + cl.size() * centralizer.order()); // 6
```

Work with group homomorphisms and the First Isomorphism Theorem:

```java
import d021248.group.homomorphism.Homomorphism;
import d021248.group.homomorphism.HomomorphismAnalyzer;

SymmetricGroup s3 = GroupFactory.symmetric(3);
CyclicGroup z2 = GroupFactory.cyclic(2);

// Sign homomorphism: S_3 → Z_2
Homomorphism<Permutation, CyclicElement> sign = new Homomorphism<>(
    s3, z2,
    p -> new CyclicElement(p.sign() == 1 ? 0 : 1, 2));

// Verify it's a valid homomorphism
boolean valid = HomomorphismAnalyzer.isHomomorphism(sign); // true

// Analyze properties
boolean injective = HomomorphismAnalyzer.isInjective(sign); // false
boolean surjective = HomomorphismAnalyzer.isSurjective(sign); // true
boolean isomorphism = HomomorphismAnalyzer.isIsomorphism(sign); // false

// Compute kernel and image
Subgroup<Permutation> kernel = HomomorphismAnalyzer.kernel(sign);
System.out.println("ker(sign) = A_3, order: " + kernel.order()); // 3

Subgroup<CyclicElement> image = HomomorphismAnalyzer.image(sign);
System.out.println("im(sign) = Z_2, order: " + image.order()); // 2

// First Isomorphism Theorem: S_3/A_3 ≅ Z_2
int quotientOrder = HomomorphismAnalyzer.firstIsomorphismTheorem(sign);
System.out.println("|S_3/A_3| = |Z_2| = " + quotientOrder); // 2

// Kernel is always normal
boolean kernelNormal = SubgroupGenerator.isNormal(s3, kernel); // true

// Compose homomorphisms
CyclicGroup z12 = GroupFactory.cyclic(12);
CyclicGroup z4 = GroupFactory.cyclic(4);

Homomorphism<CyclicElement, CyclicElement> phi = new Homomorphism<>(
    z12, z4,
    e -> new CyclicElement(e.value() % 4, 4));

Homomorphism<CyclicElement, CyclicElement> psi = new Homomorphism<>(
    z4, z2,
    e -> new CyclicElement(e.value() % 2, 2));

Homomorphism<CyclicElement, CyclicElement> composed = HomomorphismAnalyzer.compose(phi, psi);
// (ψ ∘ φ): Z_12 → Z_2
```

Explore group actions, orbits, and stabilizers:

```java
import d021248.group.action.Action;
import d021248.group.action.ActionAnalyzer;
import d021248.group.action.Orbit;

SymmetricGroup s3 = GroupFactory.symmetric(3);

// Conjugation action: G acts on itself by g · h = ghg⁻¹
Action<Permutation, Permutation> conjugation = new Action<>(
    s3,
    s3.elements(),
    (g, h) -> {
        Permutation gInv = s3.inverse(g);
        return s3.operate(s3.operate(g, h), gInv);
    });

// Verify it's a valid action
boolean valid = ActionAnalyzer.isAction(conjugation); // true

// Partition into orbits (= conjugacy classes for conjugation)
List<Orbit<Permutation>> orbits = ActionAnalyzer.orbits(conjugation);
System.out.println("Number of orbits: " + orbits.size()); // 3

// Compute orbit and stabilizer for specific element
Permutation x = new Permutation(new int[]{2, 1, 3}); // (1 2)
Orbit<Permutation> orb = ActionAnalyzer.orbit(conjugation, x);
Subgroup<Permutation> stab = ActionAnalyzer.stabilizer(conjugation, x);

// Orbit-Stabilizer Theorem: |orb(x)| × |Stab(x)| = |G|
System.out.println("|orb| × |Stab| = " + orb.size() * stab.order()); // 6
boolean theoremHolds = ActionAnalyzer.verifyOrbitStabilizer(conjugation, x); // true

// Permutation action on integers
Set<Integer> integers = Set.of(1, 2, 3);
Action<Permutation, Integer> permAction = new Action<>(
    s3,
    integers,
    (p, i) -> p.mapping()[i - 1]);

boolean transitive = ActionAnalyzer.isTransitive(permAction); // true
boolean free = ActionAnalyzer.isFree(permAction); // false (stabilizers non-trivial)

// Fixed points
Permutation trans = new Permutation(new int[]{2, 1, 3}); // (1 2)
Set<Integer> fixed = ActionAnalyzer.fixedPoints(permAction, trans);
System.out.println("Fixed by (1 2): " + fixed); // {3}

// Burnside's Lemma: count orbits using average fixed points
int numOrbits = ActionAnalyzer.burnsideLemma(conjugation);
System.out.println("Number of orbits: " + numOrbits); // 3
```

## Design Notes

* Immutability: All elements are records; operations produce new instances.
* No external logging dependency (removed for simplicity).
* `FiniteGroup#order()` provided as a default method (size of element set).
* Symmetric group generation guarded (n ≤ 9) to avoid factorial blow-up.
* `Permutation` optimizes composition by avoiding unnecessary array copies.
* Direct products work with any two finite groups (type-safe via generics).
* Subgroup verification ensures mathematical validity at construction time.

## Features

| Category | Feature | Status |
|----------|---------|--------|
| Core Groups | Cyclic (Z_n) | ✅ Complete |
| | Dihedral (D_n) | ✅ Complete |
| | Symmetric (S_n, n≤9) | ✅ Complete |
| Constructions | Direct products | ✅ Complete |
| | Subgroup generation | ✅ Complete |
| Analysis | Axiom verification | ✅ Complete |
| | Cayley tables (text/MD/LaTeX) | ✅ Complete |
| | Cayley images (visual) | ✅ Complete |
| Subgroup Tools | Generator closure | ✅ Complete |
| | All subgroups enumeration | ✅ Complete |
| | Cyclic subgroups | ✅ Complete |
| | Normality testing | ✅ Complete |
| | Normalizer/Centralizer | ✅ Complete |
| | Subgroup index | ✅ Complete |
| | Maximal subgroups | ✅ Complete |
| | Frattini subgroup | ✅ Complete |
| | Center Z(G) | ✅ Complete |
| | Commutator subgroup [G,G] | ✅ Complete |
| | Conjugacy classes | ✅ Complete |
| Homomorphisms | Group homomorphisms | ✅ Complete |
| | Kernel and image | ✅ Complete |
| | Injectivity/surjectivity | ✅ Complete |
| | First Isomorphism Theorem | ✅ Complete |
| | Composition | ✅ Complete |
| Group Actions | Actions on sets | ✅ Complete |
| | Orbits and stabilizers | ✅ Complete |
| | Orbit-Stabilizer Theorem | ✅ Complete |
| | Transitive/free actions | ✅ Complete |
| | Burnside's Lemma | ✅ Complete |
| Group Properties | isAbelian() check | ✅ Complete |
| | exponent() computation | ✅ Complete |

## Limitations / Future Ideas

| Idea | Description | Effort |
|------|-------------|--------|
| Cycle notation | Represent permutations as disjoint cycles | ✅ Done |
| Subgroup generation | Build subgroup from generator set | ✅ Done |
| Direct products | Cartesian product group implementation | ✅ Done |
| Quotient groups | G/H for normal subgroups | ✅ Done |
| Center & Commutator | Z(G) and [G,G] computation | ✅ Done |
| Conjugacy classes | Compute classes & class equation | ✅ Done |
| Homomorphisms | Group morphisms, kernels, and First Isomorphism Theorem | ✅ Done |
| Group actions | Orbits, stabilizers, and Burnside's Lemma | ✅ Done |
| Sylow subgroups | Sylow p-subgroup computation | Medium |
| Automorphism groups | Aut(G) and Inn(G) | Medium |
| Web demo | HTTP endpoints exposing Cayley tables | Medium |
| CLI REPL | Interactive exploration and verification | Low |

## Running Tests

Property-based and unit tests (requires Maven):

```bash
mvn test
```

## License

Educational / personal use. Adapt freely.

## References

* Dummit & Foote: Abstract Algebra (for deeper theory)
* Gallian: Contemporary Abstract Algebra
* Wikipedia: Group theory overview
