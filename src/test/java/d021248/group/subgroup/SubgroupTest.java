package d021248.group.subgroup;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import d021248.group.FiniteGroup;
import d021248.group.GroupFactory;
import d021248.group.cyclic.CyclicElement;
import d021248.group.cyclic.CyclicGroup;
import d021248.group.dihedral.DihedralGroup;
import d021248.group.symmetric.SymmetricGroup;
import d021248.group.util.GroupVerifier;

class SubgroupTest {

    @Test
    @DisplayName("Subgroup of Z_6 generated by <2>")
    void subgroupZ6() {
        CyclicGroup z6 = GroupFactory.cyclic(6);
        Subgroup<CyclicElement> h = SubgroupGenerator.generate(z6, Set.of(new CyclicElement(2, 6)));
        assertEquals(3, h.order()); // <2> = {0, 2, 4}
        assertTrue(h.elements().contains(new CyclicElement(0, 6)));
        assertTrue(h.elements().contains(new CyclicElement(2, 6)));
        assertTrue(h.elements().contains(new CyclicElement(4, 6)));
    }

    @Test
    @DisplayName("Trivial subgroup contains only identity")
    void trivialSubgroup() {
        CyclicGroup z5 = GroupFactory.cyclic(5);
        Subgroup<CyclicElement> triv = SubgroupGenerator.generate(z5, Set.of());
        assertEquals(1, triv.order());
        assertEquals(Set.of(z5.identity()), triv.elements());
    }

    @Test
    @DisplayName("Subgroup satisfies group axioms")
    void satisfiesGroupAxioms() {
        CyclicGroup z8 = GroupFactory.cyclic(8);
        Subgroup<CyclicElement> h = SubgroupGenerator.generate(z8, Set.of(new CyclicElement(2, 8)));
        var result = GroupVerifier.verify(h);
        assertTrue(result.ok(), result.summary());
    }

    @Test
    @DisplayName("Invalid subset throws exception")
    void invalidSubset() {
        CyclicGroup z6 = GroupFactory.cyclic(6);
        // {0, 1, 2} is not closed: 1+2=3 not in set
        Set<CyclicElement> invalid = Set.of(new CyclicElement(0, 6), new CyclicElement(1, 6),
                new CyclicElement(2, 6));
        assertThrows(IllegalArgumentException.class, () -> new Subgroup<>(z6, invalid));
    }

    @Test
    @DisplayName("Subgroup index in parent (Lagrange's theorem)")
    void subgroupIndex() {
        CyclicGroup z12 = GroupFactory.cyclic(12);
        Subgroup<CyclicElement> h = SubgroupGenerator.generate(z12, Set.of(new CyclicElement(3, 12)));
        assertEquals(4, h.order());
        assertEquals(3, h.index()); // 12 / 4
    }

    @Test
    @DisplayName("All subgroups of Z_6")
    void allSubgroupsZ6() {
        CyclicGroup z6 = GroupFactory.cyclic(6);
        List<Subgroup<CyclicElement>> subs = SubgroupGenerator.allSubgroups(z6);
        // Z_6 has subgroups: {e}, <1>=Z_6, <2>, <3>
        assertEquals(4, subs.size());
        assertTrue(subs.stream().anyMatch(s -> s.order() == 1)); // trivial
        assertTrue(subs.stream().anyMatch(s -> s.order() == 2)); // <3>
        assertTrue(subs.stream().anyMatch(s -> s.order() == 3)); // <2>
        assertTrue(subs.stream().anyMatch(s -> s.order() == 6)); // whole group
    }

    @Test
    @DisplayName("Cyclic subgroups of Z_12")
    void cyclicSubgroupsZ12() {
        CyclicGroup z12 = GroupFactory.cyclic(12);
        List<Subgroup<CyclicElement>> cyclic = SubgroupGenerator.cyclicSubgroups(z12);
        // Each divisor d of 12 gives one cyclic subgroup of order d
        assertTrue(cyclic.stream().anyMatch(s -> s.order() == 1));
        assertTrue(cyclic.stream().anyMatch(s -> s.order() == 2));
        assertTrue(cyclic.stream().anyMatch(s -> s.order() == 3));
        assertTrue(cyclic.stream().anyMatch(s -> s.order() == 4));
        assertTrue(cyclic.stream().anyMatch(s -> s.order() == 6));
        assertTrue(cyclic.stream().anyMatch(s -> s.order() == 12));
    }

    @Test
    @DisplayName("Normal subgroup detection")
    void normalSubgroup() {
        // In abelian groups, all subgroups are normal
        CyclicGroup z6 = GroupFactory.cyclic(6);
        Subgroup<CyclicElement> h = SubgroupGenerator.generate(z6, Set.of(new CyclicElement(2, 6)));
        assertTrue(SubgroupGenerator.isNormal(z6, h));
    }

    @Test
    @DisplayName("Non-normal subgroup in S_3")
    void nonNormalSubgroup() {
        SymmetricGroup s3 = GroupFactory.symmetric(3);
        List<Subgroup<d021248.group.symmetric.Permutation>> subs = SubgroupGenerator.allSubgroups(s3);
        var order2Subs = subs.stream().filter(s -> s.order() == 2).toList();
        // In S_3, order-2 subgroups (generated by transpositions) are not normal
        assertFalse(order2Subs.isEmpty());
        for (var sub : order2Subs) {
            assertFalse(SubgroupGenerator.isNormal(s3, sub));
        }
    }

    @Test
    @DisplayName("Normalizer of subgroup")
    void normalizer() {
        CyclicGroup z6 = GroupFactory.cyclic(6);
        Subgroup<CyclicElement> h = SubgroupGenerator.generate(z6, Set.of(new CyclicElement(3, 6)));
        Subgroup<CyclicElement> n = SubgroupGenerator.normalizer(z6, h);
        // In abelian groups, normalizer is the whole group
        assertEquals(z6.order(), n.order());
    }

    @Test
    @DisplayName("Centralizer of subgroup")
    void centralizer() {
        DihedralGroup d4 = GroupFactory.dihedral(4);
        List<Subgroup<d021248.group.dihedral.DihedralElement>> subs = SubgroupGenerator.cyclicSubgroups(d4);
        // Pick a non-trivial cyclic subgroup
        var h = subs.stream().filter(s -> s.order() > 1 && s.order() < d4.order()).findFirst().orElseThrow();
        Subgroup<d021248.group.dihedral.DihedralElement> c = SubgroupGenerator.centralizer(d4, h);
        // Centralizer contains at least the subgroup itself
        assertTrue(c.order() >= h.order());
    }

    @Test
    @DisplayName("Large group throws for all subgroups")
    void largeGroupThrows() {
        CyclicGroup z30 = GroupFactory.cyclic(30);
        assertThrows(IllegalArgumentException.class, () -> SubgroupGenerator.allSubgroups(z30));
    }

    @Test
    @DisplayName("Parent group access")
    void parentAccess() {
        CyclicGroup z10 = GroupFactory.cyclic(10);
        Subgroup<CyclicElement> h = SubgroupGenerator.generate(z10, Set.of(new CyclicElement(5, 10)));
        FiniteGroup<CyclicElement> parent = h.parent();
        assertEquals(z10, parent);
    }
}
