package d021248.group.subgroup;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import d021248.group.Generator;
import d021248.group.Group;
import d021248.group.api.Element;
import d021248.group.util.Constants;

/**
 * Utilities for generating subgroups of finite groups.
 * <p>
 * Example usage:
 * </p>
 * 
 * <pre>
 * {
 *     &#64;code
 *     // Generate subgroup from elements
 *     CyclicGroup z12 = new CyclicGroup(12);
 *     Subgroup<CyclicElement> h = SubgroupGenerator.generate(z12, Set.of(new CyclicElement(3, 12)));
 *     System.out.println(h.order()); // 4 (elements: 0, 3, 6, 9)
 * 
 *     // Find all subgroups
 *     List<Subgroup<CyclicElement>> allSubs = SubgroupGenerator.allSubgroups(z12);
 *     System.out.println(allSubs.size()); // 6 (divisors of 12)
 * 
 *     // Check normality (moved to SubgroupAnalyzer)
 *     boolean normal = SubgroupAnalyzer.isNormal(z12, h); // true (abelian)
 * 
 *     // Special subgroups (moved to SpecialSubgroups)
 *     Subgroup<CyclicElement> center = SpecialSubgroups.center(z12);
 * }
 * </pre>
 * 
 * @see SubgroupAnalyzer for normality testing and computing
 *      normalizers/centralizers
 * @see SpecialSubgroups for center, commutator, Frattini, and maximal subgroups
 */
public final class SubgroupGenerator {

    private SubgroupGenerator() {
    }

    /**
     * Generate the subgroup from a set of generators within the parent group.
     * <p>
     * Uses the closure algorithm to find all elements reachable from the generators
     * under the group operation.
     * </p>
     */
    public static <E extends Element> Subgroup<E> generate(Group<E> parent, Set<E> generators) {
        Objects.requireNonNull(parent, Constants.NULL_PARENT);
        Objects.requireNonNull(generators, Constants.NULL_GENERATORS);
        Set<E> closure = Generator.generate(parent, generators);
        return new Subgroup<>(parent, closure);
    }

    /**
     * Generate all subgroups of a finite group.
     * <p>
     * Uses a lattice enumeration approach: for each subset of elements, check if it
     * forms a subgroup. This is exponential in the group size and practical only
     * for small groups (order ≤ 20).
     * </p>
     * <p>
     * <b>Performance:</b> O(2^n × n²) where n is the group order.
     * Restricted to groups with order ≤
     * {@value d021248.group.util.Constants#MAX_SUBGROUP_ENUMERATION_SIZE}.
     * </p>
     * 
     * @return List of all subgroups including trivial ({e}) and the group itself
     */
    public static <E extends Element> List<Subgroup<E>> allSubgroups(Group<E> parent) {
        Objects.requireNonNull(parent, Constants.NULL_PARENT);
        if (parent.order() > Constants.MAX_SUBGROUP_ENUMERATION_SIZE) {
            throw new IllegalArgumentException(
                    "Enumerating all subgroups is only practical for small groups (order ≤ "
                            + Constants.MAX_SUBGROUP_ENUMERATION_SIZE + ")");
        }
        List<Subgroup<E>> subgroups = new ArrayList<>();
        List<E> elements = new ArrayList<>(parent.elements());
        int n = elements.size();
        // Enumerate all subsets (2^n possibilities)
        for (int mask = 1; mask < (1 << n); mask++) {
            Set<E> subset = buildSubset(elements, mask);
            if (isSubgroup(parent, subset)) {
                subgroups.add(new Subgroup<>(parent, subset));
            }
        }
        return subgroups;
    }

    private static <E extends Element> Set<E> buildSubset(List<E> elements, int mask) {
        Set<E> subset = new HashSet<>();
        for (int i = 0; i < elements.size(); i++) {
            if ((mask & (1 << i)) != 0) {
                subset.add(elements.get(i));
            }
        }
        return subset;
    }

    private static <E extends Element> boolean isSubgroup(Group<E> parent, Set<E> subset) {
        if (subset.isEmpty() || !subset.contains(parent.identity()))
            return false;
        // Check closure and inverses
        for (E a : subset) {
            E inv = parent.inverse(a);
            if (!subset.contains(inv))
                return false;
            for (E b : subset) {
                E prod = parent.operate(a, b);
                if (!subset.contains(prod))
                    return false;
            }
        }
        return true;
    }

    /**
     * Find all cyclic subgroups of a finite group (subgroups generated by a single
     * element).
     * <p>
     * <b>Performance:</b> O(n² × log n) where n is the group order.
     * Generates and deduplicates n cyclic subgroups.
     * </p>
     */
    public static <E extends Element> List<Subgroup<E>> cyclicSubgroups(Group<E> parent) {
        Objects.requireNonNull(parent, Constants.NULL_PARENT);
        List<Subgroup<E>> cyclic = new ArrayList<>();
        Set<Set<E>> seen = new HashSet<>();
        for (E g : parent.elements()) {
            Set<E> closure = Generator.generate(parent, Set.of(g));
            if (!seen.contains(closure)) {
                seen.add(closure);
                cyclic.add(new Subgroup<>(parent, closure));
            }
        }
        return cyclic;
    }
}
