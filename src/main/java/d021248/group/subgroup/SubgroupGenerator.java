package d021248.group.subgroup;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import d021248.group.Generator;
import d021248.group.Group;
import d021248.group.api.Element;

/**
 * Utilities for generating and analyzing subgroups of finite groups.
 * <p>
 * Example usage:
 * </p>
 * 
 * <pre>
 * {
 *     &#64;code
 *     // Generate subgroup from elements
 *     CyclicGroup z12 = new CyclicGroup(12);
 *     Subgroup<CyclicElement> h = SubgroupGenerator.generate(z12, Set.of(new CyclicElement(3, 12)));
 *     System.out.println(h.order()); // 4 (elements: 0, 3, 6, 9)
 * 
 *     // Find all subgroups
 *     List<Subgroup<CyclicElement>> allSubs = SubgroupGenerator.allSubgroups(z12);
 *     System.out.println(allSubs.size()); // 6 (divisors of 12)
 * 
 *     // Check normality
 *     boolean normal = SubgroupGenerator.isNormal(z12, h); // true (abelian)
 * }
 * </pre>
 */
public final class SubgroupGenerator {
    private static final String PARENT_NULL_MSG = "parent group must not be null";

    private SubgroupGenerator() {
    }

    /**
     * Generate the subgroup from a set of generators within the parent group.
     * <p>
     * Uses the closure algorithm to find all elements reachable from the generators
     * under the group operation.
     * </p>
     */
    public static <E extends Element> Subgroup<E> generate(Group<E> parent, Set<E> generators) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        Objects.requireNonNull(generators, "generators must not be null");
        Set<E> closure = Generator.generate(parent, generators);
        return new Subgroup<>(parent, closure);
    }

    /**
     * Generate all subgroups of a finite group.
     * <p>
     * Uses a lattice enumeration approach: for each subset of elements, check if it
     * forms a subgroup. This is exponential in the group size and practical only
     * for small groups (order ≤ 20).
     * </p>
     * 
     * @return List of all subgroups including trivial ({e}) and the group itself
     */
    public static <E extends Element> List<Subgroup<E>> allSubgroups(Group<E> parent) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        if (parent.order() > 20) {
            throw new IllegalArgumentException(
                    "Enumerating all subgroups is only practical for small groups (order ≤ 20)");
        }
        List<Subgroup<E>> subgroups = new ArrayList<>();
        List<E> elements = new ArrayList<>(parent.elements());
        int n = elements.size();
        // Enumerate all subsets (2^n possibilities)
        for (int mask = 1; mask < (1 << n); mask++) {
            Set<E> subset = buildSubset(elements, mask);
            if (isSubgroup(parent, subset)) {
                subgroups.add(new Subgroup<>(parent, subset));
            }
        }
        return subgroups;
    }

    private static <E extends Element> Set<E> buildSubset(List<E> elements, int mask) {
        Set<E> subset = new HashSet<>();
        for (int i = 0; i < elements.size(); i++) {
            if ((mask & (1 << i)) != 0) {
                subset.add(elements.get(i));
            }
        }
        return subset;
    }

    private static <E extends Element> boolean isSubgroup(Group<E> parent, Set<E> subset) {
        if (subset.isEmpty() || !subset.contains(parent.identity()))
            return false;
        // Check closure and inverses
        for (E a : subset) {
            E inv = parent.inverse(a);
            if (!subset.contains(inv))
                return false;
            for (E b : subset) {
                E prod = parent.operate(a, b);
                if (!subset.contains(prod))
                    return false;
            }
        }
        return true;
    }

    /**
     * Find all cyclic subgroups of a finite group (subgroups generated by a single
     * element).
     */
    public static <E extends Element> List<Subgroup<E>> cyclicSubgroups(Group<E> parent) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        List<Subgroup<E>> cyclic = new ArrayList<>();
        Set<Set<E>> seen = new HashSet<>();
        for (E g : parent.elements()) {
            Set<E> closure = Generator.generate(parent, Set.of(g));
            if (!seen.contains(closure)) {
                seen.add(closure);
                cyclic.add(new Subgroup<>(parent, closure));
            }
        }
        return cyclic;
    }

    /**
     * Compute the normalizer of a subgroup H in parent group G: N_G(H) = {g ∈ G :
     * gHg⁻¹ = H}.
     */
    public static <E extends Element> Subgroup<E> normalizer(Group<E> parent, Subgroup<E> subgroup) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        Objects.requireNonNull(subgroup, "subgroup must not be null");
        Set<E> normalizer = new HashSet<>();
        for (E g : parent.elements()) {
            if (conjugatesTo(parent, g, subgroup.elements(), subgroup.elements())) {
                normalizer.add(g);
            }
        }
        return new Subgroup<>(parent, normalizer);
    }

    private static <E extends Element> boolean conjugatesTo(Group<E> parent, E g, Set<E> source, Set<E> target) {
        E gInv = parent.inverse(g);
        Set<E> conjugated = new HashSet<>();
        for (E h : source) {
            E ghg = parent.operate(parent.operate(g, h), gInv);
            conjugated.add(ghg);
        }
        return conjugated.equals(target);
    }

    /**
     * Compute the centralizer of a subgroup H in parent group G: C_G(H) = {g ∈ G :
     * gh = hg for all h ∈ H}.
     */
    public static <E extends Element> Subgroup<E> centralizer(Group<E> parent, Subgroup<E> subgroup) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        Objects.requireNonNull(subgroup, "subgroup must not be null");
        Set<E> centralizer = new HashSet<>();
        for (E g : parent.elements()) {
            if (commutesWith(parent, g, subgroup.elements())) {
                centralizer.add(g);
            }
        }
        return new Subgroup<>(parent, centralizer);
    }

    private static <E extends Element> boolean commutesWith(Group<E> parent, E g, Set<E> elements) {
        for (E h : elements) {
            E gh = parent.operate(g, h);
            E hg = parent.operate(h, g);
            if (!gh.equals(hg))
                return false;
        }
        return true;
    }

    /**
     * Check if a subgroup is normal (gHg⁻¹ = H for all g ∈ G).
     */
    public static <E extends Element> boolean isNormal(Group<E> parent, Subgroup<E> subgroup) {
        return normalizer(parent, subgroup).order() == parent.order();
    }

    /**
     * Find all maximal proper subgroups of the group.
     * <p>
     * A maximal subgroup is a proper subgroup that is not contained in any other
     * proper subgroup. For groups of order ≤ 20, this enumerates all subgroups and
     * filters for maximality.
     * </p>
     * 
     * @param parent the parent group
     * @return list of all maximal proper subgroups
     * @throws IllegalArgumentException if group order > 20 (performance limit)
     */
    public static <E extends Element> List<Subgroup<E>> maximalSubgroups(Group<E> parent) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        int n = parent.order();
        if (n > 20) {
            throw new IllegalArgumentException(
                    "maximalSubgroups only supported for order ≤ 20 (given: " + n + ")");
        }

        List<Subgroup<E>> all = allSubgroups(parent);
        List<Subgroup<E>> maximal = new ArrayList<>();

        // A subgroup H is maximal if it's proper and no other proper subgroup contains
        // it
        for (Subgroup<E> h : all) {
            if (h.order() == parent.order()) {
                continue; // skip the whole group (not proper)
            }

            boolean isMaximal = true;
            for (Subgroup<E> k : all) {
                // If H ⊂ K (proper containment), then H is not maximal
                if (k.order() > h.order() && k.order() < parent.order()
                        && k.elements().containsAll(h.elements())) {
                    isMaximal = false;
                    break;
                }
            }
            if (isMaximal) {
                maximal.add(h);
            }
        }
        return maximal;
    }

    /**
     * Compute the Frattini subgroup Φ(G) - the intersection of all maximal
     * subgroups.
     * <p>
     * The Frattini subgroup is the set of "non-generators": elements that can be
     * removed from any generating set without losing the property of generating the
     * whole group.
     * </p>
     * <p>
     * Special cases:
     * </p>
     * <ul>
     * <li>If G has no maximal subgroups (only happens for trivial group), Φ(G) =
     * G</li>
     * <li>For cyclic groups of prime order, Φ(G) = {e}</li>
     * <li>For p-groups, Φ(G) is always non-trivial (unless G is trivial)</li>
     * </ul>
     * 
     * @param parent the parent group
     * @return the Frattini subgroup
     * @throws IllegalArgumentException if group order > 20 (performance limit)
     */
    public static <E extends Element> Subgroup<E> frattiniSubgroup(Group<E> parent) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);

        List<Subgroup<E>> maximal = maximalSubgroups(parent);

        if (maximal.isEmpty()) {
            // No maximal subgroups means Φ(G) contains only the identity
            return new Subgroup<>(parent, Set.of(parent.identity()));
        }

        // Intersect all maximal subgroups
        Set<E> intersection = new HashSet<>(maximal.get(0).elements());
        for (int i = 1; i < maximal.size(); i++) {
            intersection.retainAll(maximal.get(i).elements());
        }

        return new Subgroup<>(parent, intersection);
    }
}
