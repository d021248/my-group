package d021248.group.subgroup;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import d021248.group.FiniteGroup;
import d021248.group.Generator;
import d021248.group.api.Element;

/**
 * Utilities for generating and analyzing subgroups of finite groups.
 */
public final class SubgroupGenerator {
    private static final String PARENT_NULL_MSG = "parent group must not be null";

    private SubgroupGenerator() {
    }

    /**
     * Generate the subgroup from a set of generators within the parent group.
     * <p>
     * Uses the closure algorithm to find all elements reachable from the generators
     * under the group operation.
     * </p>
     */
    public static <E extends Element> Subgroup<E> generate(FiniteGroup<E> parent, Set<E> generators) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        Objects.requireNonNull(generators, "generators must not be null");
        Set<E> closure = Generator.generate(parent, generators);
        return new Subgroup<>(parent, closure);
    }

    /**
     * Generate all subgroups of a finite group.
     * <p>
     * Uses a lattice enumeration approach: for each subset of elements, check if it
     * forms a subgroup. This is exponential in the group size and practical only
     * for small groups (order ≤ 20).
     * </p>
     * 
     * @return List of all subgroups including trivial ({e}) and the group itself
     */
    public static <E extends Element> List<Subgroup<E>> allSubgroups(FiniteGroup<E> parent) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        if (parent.order() > 20) {
            throw new IllegalArgumentException(
                    "Enumerating all subgroups is only practical for small groups (order ≤ 20)");
        }
        List<Subgroup<E>> subgroups = new ArrayList<>();
        List<E> elements = new ArrayList<>(parent.elements());
        int n = elements.size();
        // Enumerate all subsets (2^n possibilities)
        for (int mask = 1; mask < (1 << n); mask++) {
            Set<E> subset = buildSubset(elements, mask);
            if (isSubgroup(parent, subset)) {
                subgroups.add(new Subgroup<>(parent, subset));
            }
        }
        return subgroups;
    }

    private static <E extends Element> Set<E> buildSubset(List<E> elements, int mask) {
        Set<E> subset = new HashSet<>();
        for (int i = 0; i < elements.size(); i++) {
            if ((mask & (1 << i)) != 0) {
                subset.add(elements.get(i));
            }
        }
        return subset;
    }

    private static <E extends Element> boolean isSubgroup(FiniteGroup<E> parent, Set<E> subset) {
        if (subset.isEmpty() || !subset.contains(parent.identity()))
            return false;
        // Check closure and inverses
        for (E a : subset) {
            E inv = parent.inverse(a);
            if (!subset.contains(inv))
                return false;
            for (E b : subset) {
                E prod = parent.operate(a, b);
                if (!subset.contains(prod))
                    return false;
            }
        }
        return true;
    }

    /**
     * Find all cyclic subgroups of a finite group (subgroups generated by a single
     * element).
     */
    public static <E extends Element> List<Subgroup<E>> cyclicSubgroups(FiniteGroup<E> parent) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        List<Subgroup<E>> cyclic = new ArrayList<>();
        Set<Set<E>> seen = new HashSet<>();
        for (E g : parent.elements()) {
            Set<E> closure = Generator.generate(parent, Set.of(g));
            if (!seen.contains(closure)) {
                seen.add(closure);
                cyclic.add(new Subgroup<>(parent, closure));
            }
        }
        return cyclic;
    }

    /**
     * Compute the normalizer of a subgroup H in parent group G: N_G(H) = {g ∈ G :
     * gHg⁻¹ = H}.
     */
    public static <E extends Element> Subgroup<E> normalizer(FiniteGroup<E> parent, Subgroup<E> subgroup) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        Objects.requireNonNull(subgroup, "subgroup must not be null");
        Set<E> normalizer = new HashSet<>();
        for (E g : parent.elements()) {
            if (conjugatesTo(parent, g, subgroup.elements(), subgroup.elements())) {
                normalizer.add(g);
            }
        }
        return new Subgroup<>(parent, normalizer);
    }

    private static <E extends Element> boolean conjugatesTo(FiniteGroup<E> parent, E g, Set<E> source, Set<E> target) {
        E gInv = parent.inverse(g);
        Set<E> conjugated = new HashSet<>();
        for (E h : source) {
            E ghg = parent.operate(parent.operate(g, h), gInv);
            conjugated.add(ghg);
        }
        return conjugated.equals(target);
    }

    /**
     * Compute the centralizer of a subgroup H in parent group G: C_G(H) = {g ∈ G :
     * gh = hg for all h ∈ H}.
     */
    public static <E extends Element> Subgroup<E> centralizer(FiniteGroup<E> parent, Subgroup<E> subgroup) {
        Objects.requireNonNull(parent, PARENT_NULL_MSG);
        Objects.requireNonNull(subgroup, "subgroup must not be null");
        Set<E> centralizer = new HashSet<>();
        for (E g : parent.elements()) {
            if (commutesWith(parent, g, subgroup.elements())) {
                centralizer.add(g);
            }
        }
        return new Subgroup<>(parent, centralizer);
    }

    private static <E extends Element> boolean commutesWith(FiniteGroup<E> parent, E g, Set<E> elements) {
        for (E h : elements) {
            E gh = parent.operate(g, h);
            E hg = parent.operate(h, g);
            if (!gh.equals(hg))
                return false;
        }
        return true;
    }

    /**
     * Check if a subgroup is normal (gHg⁻¹ = H for all g ∈ G).
     */
    public static <E extends Element> boolean isNormal(FiniteGroup<E> parent, Subgroup<E> subgroup) {
        return normalizer(parent, subgroup).order() == parent.order();
    }
}
